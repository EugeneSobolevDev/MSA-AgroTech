### <a name="_b7urdng99y53"></a>**Выбор стратегии мультитенантности для SaaS-платформы мониторинга скота**
### <a name="_hjk0fkfyohdk"></a>**Автор: Соболев Е.В.**
### <a name="_uanumrh8zrui"></a>**Дата: 07.12.2025**
### <a name="_3bfxc9a45514"></a>**Функциональные требования**
В ADR 001: Платформа для мониторинга скота был выбран вариант "Автономные агенты (Edge-система)", 
теперь необходимо определить стратегию мультитенантности для превращения решения в SaaS-продукт.

После успешного внедрения MVP на своих фермах компания собирается вывести решение как коммерческую SaaS-платформу для других агрохолдингов. 
Требования к SaaS-платформе.
Платформа должна:
- обеспечивать полную изоляцию данных между клиентами;
- поддерживать гибкую систему подписок с разными тарифными планами;
- предоставлять API для интеграции с системами клиентов (варианты прорабатываются);
- иметь панель самообслуживания для управления аккаунтом (однако пока нет специального интерфейса администратора);
- масштабироваться горизонтально по мере роста числа клиентов;
- собирать метрики использования для аналитики и биллинга.
- для биллинга и монетизации нужна интеграция с российскими платёжными системами, а для онбординга — документация и API для самостоятельной интеграции.

Рассмотренные варианты
Вариант 1: Изоляция на уровне схем БД
@startuml SaaS_C2_Вариант_1
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(клиент1, "Ферма А", "Работает с сервисом")
Person(клиент2, "Ферма Б", "Работает с сервисом")
Person(админ, "Администратор", "Управляет платформой")

System_Boundary(система, "SaaS Платформа мониторинга скота") {

    Container_Boundary(агент_фермы_клиент1, "Агент фермы - Клиент А") {
        Container(ml_клиент1, "ML сервер", "ML модели", "Обработка видеопотоков")
        ContainerDb(бд_клиент1, "Локальная БД", "PostgreSQL", "Кэш данных фермы")
    }

    Container_Boundary(агент_фермы_клиент2, "Агент фермы - Клиент Б") {
        Container(ml_клиент2, "ML сервер", "ML модели", "Обработка видеопотоков")
        ContainerDb(бд_клиент2, "Локальная БД", "PostgreSQL", "Кэш данных фермы")
    }

    Container_Boundary(центральный_сервер, "Центральный сервер SaaS") {
        Container(api_шлюз, "API Gateway", "Java + Tenant ID", "Маршрутизация по tenant_id")
        Container(сервис_агрегации, "Сервис агрегации", "Java", "Обработка данных всех клиентов")
        ContainerDb(центральная_бд, "Центральная БД", "PostgreSQL", "Все схемы клиентов в одном инстансе")

        Container_Boundary(tenant_schemas, "Схемы БД по клиентам") {
            ContainerDb(схема_клиент1, "Схема: tenant_a", "PostgreSQL", "Данные клиента А")
            ContainerDb(схема_клиент2, "Схема: tenant_b", "PostgreSQL", "Данные клиента Б")
            ContainerDb(схема_общая, "Схема: shared", "PostgreSQL", "Общие справочники, пользователи")
        }

        Container(веб_портал, "Веб-портал", "React + Tenant", "Мультитенантный UI")
    }
}

Rel(клиент1, веб_портал, "Работает через портал", "HTTPS + tenant_id")
Rel(клиент2, веб_портал, "Работает через портал", "HTTPS + tenant_id")
Rel(админ, веб_портал, "Управляет всеми клиентами", "HTTPS + admin")

Rel(бд_клиент1, сервис_агрегации, "Синхронизация", "HTTPS + tenant_id")
Rel(бд_клиент2, сервис_агрегации, "Синхронизация", "HTTPS + tenant_id")
Rel(сервис_агрегации, схема_клиент1, "Запись данных", "SQL (схема tenant_заря)")
Rel(сервис_агрегации, схема_клиент2, "Запись данных", "SQL (схема tenant_рассвет)")

Rel(веб_портал, api_шлюз, "API запросы", "HTTPS + JWT с tenant_id")
Rel(api_шлюз, сервис_агрегации, "Маршрутизация по tenant", "gRPC + tenant контекст")

Rel(схема_клиент1, схема_общая, "Ссылки на общие данные", "SQL")
Rel(схема_клиент2, схема_общая, "Ссылки на общие данные", "SQL")

@endumlhttps://SaaS_C2_%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82_1

Характеристики:
- Уровень изоляции: Логическая (схемы в одной БД)
- Общие ресурсы: Один инстанс PostgreSQL
- Механизм изоляции: Отдельные схемы + права доступа
- Маршрутизация: API Gateway на основе tenant_id выбирает схему БД.

Преимущества:
- Низкая стоимость инфраструктуры
- Простота управления и резервного копирования
- Простота работы с БД

Недостатки:
- Риск утечки данных
- Сложность масштабирования (один инстанс БД)
- Влияние нагрузки одного клиента на других

Вариант 2: Изоляция на уровне отдельных БД
@startuml SaaS_C2_Вариант_2
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(клиент1, "Ферма А", "Работает с сервисом")
Person(клиент2, "Ферма Б", "Работает с сервисом")
Person(админ, "Администратор", "Управляет платформой")

System_Boundary(система, "SaaS Платформа мониторинга скота") {

    Container_Boundary(агент_фермы_клиент1, "Агент фермы - Клиент А") {
        Container(ml_клиент1, "ML сервер", "ML модели", "Обработка видеопотоков")
        ContainerDb(бд_клиент1, "Локальная БД", "PostgreSQL", "Кэш данных фермы")
    }

    Container_Boundary(агент_фермы_клиент2, "Агент фермы - Клиент Б") {
        Container(ml_клиент2, "ML сервер", "ML модели", "Обработка видеопотоков")
        ContainerDb(бд_клиент2, "Локальная БД", "PostgreSQL", "Кэш данных фермы")
    }

    Container_Boundary(центральный_сервер, "Центральный сервер SaaS") {
        Container(api_шлюз, "API Gateway", "Java + DB Routing", "Динамическая маршрутизация к БД")
        Container(сервис_агрегации, "Сервис агрегации", "Java", "Агрегирует данные из локальных БД ферм")

        ContainerDb(бд_общая, "Общая БД", "PostgreSQL", "Метаданные, пользователи, биллинг")

        Container_Boundary(tenant_databases, "Отдельные БД клиентов") {
            ContainerDb(бд_клиент1_ц, "БД: db_tenant_a", "PostgreSQL", "Изолированные данные клиента А")
            ContainerDb(бд_клиент2_ц, "БД: db_tenant_b", "PostgreSQL", "Изолированные данные клиента Б")
        }

        Container(менеджер_подключений, "Менеджер подключений", "Java + HikariCP", "Пул соединений к разным БД")
        Container(веб_портал, "Веб-портал", "React", "Мультитенантный UI с выбором БД")
    }
}

Rel(клиент1, веб_портал, "Работает через портал", "HTTPS → перенаправление к своей БД")
Rel(клиент2, веб_портал, "Работает через портал", "HTTPS → перенаправление к своей БД")
Rel(админ, веб_портал, "Управляет клиентами", "HTTPS → доступ ко всем БД")

Rel(бд_клиент1, сервис_агрегации, "Синхронизация", "HTTPS + tenant")
Rel(бд_клиент2, сервис_агрегации, "Синхронизация", "HTTPS + tenant")

Rel(веб_портал, api_шлюз, "API запросы", "HTTPS с tenant")
Rel(api_шлюз, менеджер_подключений, "Определение БД клиента", "согласно tenant")
Rel(менеджер_подключений, бд_клиент1, "Подключение к БД клиента А", "JDBC:tenant_a")
Rel(менеджер_подключений, бд_клиент2, "Подключение к БД клиента Б", "JDBC:tenant_b")

Rel(сервис_агрегации, менеджер_подключений, "Запрос подключения", "tenant")
Rel(менеджер_подключений, сервис_агрегации, "Возврат DataSource", "Hikari DataSource")

Rel(api_шлюз, бд_общая, "Проверка клиента, аутентификация", "SQL")
Rel(менеджер_подключений, бд_общая, "Получение конфигураций БД", "SQL: конфиг нода")

@enduml

Характеристики:
- Уровень изоляции: Физическая (отдельные БД)
- Общие ресурсы: Сервер приложения, но разные инстансы БД
- Механизм изоляции: Разные connection strings
- Маршрутизация: Менеджер подключений, динамический DataSource

Преимущества:
- Высокий уровень безопасности (физическая изоляция)
- Лучшая производительность
- Возможность разного размера/конфигурации БД для разных клиентов

Недостатки:
- Высокая стоимость инфраструктуры
- Сложность управления
- Сложность выполнения кросс-тенантных запросов
- Больше точек отказа

### Основной выбор
Вариант 2. Изоляция на уровне отдельных БД.
Обоснование:
Безопасность данных. Физическая изоляция минимизирует риски утечек.
Масштабируемость: По мере роста числа клиентов, подход с отдельными БД позволяет:
- Легко переносить крупных клиентов на выделенные инстансы
- Применять разные стратегии бэкапа и восстановления
- Оптимизировать производительность под каждого клиента и тариф